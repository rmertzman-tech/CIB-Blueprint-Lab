<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UCP v2.0: The P-Adic Geometry of Agency</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-color: #1e293b;
            --text-color: #e2e8f0;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-gold: #f59e0b;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #334155;
            margin-bottom: 20px;
        }

        h1 { margin: 0; font-size: 1.5rem; }
        .subtitle { color: #94a3b8; font-size: 0.9rem; }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            height: 100%;
        }

        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #334155;
        }

        /* Controls */
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.9rem; }
        input[type="range"] { width: 100%; margin-bottom: 5px; cursor: pointer; }
        .value-display { font-family: monospace; color: var(--accent-blue); float: right; }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-biobond { background-color: var(--accent-green); color: #fff; }
        .btn-biobond:hover { background-color: #059669; }
        .btn-reset { background-color: var(--panel-color); border: 1px solid #64748b; color: #fff; }
        .btn-strategy { background-color: #475569; color: #fff; margin-bottom: 5px;}
        .btn-strategy.active { background-color: var(--accent-blue); border: 1px solid #fff; }

        /* Visualization */
        #simCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            border-radius: 8px;
        }

        /* Metrics */
        .metric-card {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid var(--accent-blue);
        }
        .metric-title { font-size: 0.8rem; color: #94a3b8; text-transform: uppercase; }
        .metric-value { font-size: 1.2rem; font-weight: bold; font-family: monospace; }
        
        .log-feed {
            font-family: monospace;
            font-size: 0.8rem;
            height: 200px;
            overflow-y: auto;
            color: #94a3b8;
            border-top: 1px solid #334155;
            padding-top: 10px;
            margin-top: 10px;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .log-warn { color: var(--accent-red); }
        .log-success { color: var(--accent-green); }
        .log-info { color: var(--accent-blue); }

        /* Legend */
        .legend { display: flex; gap: 10px; margin-top: 10px; font-size: 0.8rem; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .info-box { font-size: 0.85rem; line-height: 1.4; color: #cbd5e1; margin-bottom: 15px;}

    </style>
</head>
<body>

<header>
    <div>
        <h1>The Constructor's Dashboard</h1>
        <div class="subtitle">UCP v2.0: P-Adic Physics Engine & Social Simulation</div>
    </div>
    <div style="text-align: right;">
        <span id="simTime">Step: 0</span>
    </div>
</header>

<div class="dashboard-grid">
    <div class="panel">
        <h3>System Parameters</h3>
        <div class="info-box">
            Adjust the thermodynamic variables to observe the geometry of agency.
        </div>

        <div class="control-group">
            <label>Env. Entropy (Noise) <span id="val-entropy" class="value-display">0.2</span></label>
            <input type="range" id="entropySlider" min="0" max="1.5" step="0.05" value="0.2">
            <small style="color: #64748b;">High noise forces Truncation.</small>
        </div>

        <div class="control-group">
            <label>Metabolic Budget (P_max) <span id="val-budget" class="value-display">4.0</span></label>
            <input type="range" id="budgetSlider" min="1.0" max="10.0" step="0.5" value="4.0">
            <small style="color: #64748b;">Energy available for Landauer cost.</small>
        </div>

        <h3>Social Contract</h3>
        <button class="btn-strategy" onclick="setStrategy('Hobbes')">Hobbes (Protect Roots)</button>
        <button class="btn-strategy" onclick="setStrategy('Nozick')">Nozick (Protect Edge)</button>
        <button class="btn-strategy active" onclick="setStrategy('Rawls')">Rawls (Balanced)</button>
        
        <hr style="border-color: #334155; margin: 15px 0;">
        
        <button class="btn-biobond" id="biobondBtn" onclick="toggleBioBond()">ACTIVATE BIOBOND</button>
        <button class="btn-reset" onclick="resetSim()">Reset Simulation</button>
    </div>

    <div class="panel" style="padding: 0; position: relative;">
        <canvas id="simCanvas"></canvas>
        <div style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 4px;">
            <div class="legend">
                <div><span class="dot" style="background:#f59e0b"></span> Root (Survival)</div>
                <div><span class="dot" style="background:#3b82f6"></span> Trunk (Culture)</div>
                <div><span class="dot" style="background:#10b981"></span> Edge (Agency)</div>
            </div>
        </div>
    </div>

    <div class="panel">
        <h3>Thermodynamic Metrics</h3>
        
        <div class="metric-card" style="border-left-color: var(--accent-red);">
            <div class="metric-title">Avg Stress (L_GC)</div>
            <div class="metric-value" id="disp-stress">0.00</div>
            <small>Sapolsky Limit: > 0.65</small>
        </div>

        <div class="metric-card" style="border-left-color: var(--accent-blue);">
            <div class="metric-title">System Lambda (Î»)</div>
            <div class="metric-value" id="disp-lambda">0.00</div>
            <small>Collective Intelligence</small>
        </div>

        <div class="metric-card" style="border-left-color: var(--accent-green);">
            <div class="metric-title">Avg Logical Depth (N)</div>
            <div class="metric-value" id="disp-depth">0.0</div>
            <small>P-Adic Precision</small>
        </div>

        <div class="metric-card" style="border-left-color: var(--accent-gold);">
            <div class="metric-title">Group Friction</div>
            <div class="metric-value" id="disp-friction">0.0</div>
            <small>Ultrametric Diameter</small>
        </div>

        <h3>Event Log</h3>
        <div class="log-feed" id="logFeed">
            <div class="log-entry log-info">Simulation Initialized.</div>
        </div>
    </div>
</div>

<script>
/**
 * UCP v2.0 - CANONICAL P-ADIC PHYSICS ENGINE (JS PORT)
 * Logic derived from provided Python specs.
 */

// --- PARAMETERS ---
const PARAMS = {
    PRIME_BASE: 7,
    THETA_CRIT: 0.65,      // Critical stress
    K_GATE: 15.0,          // Sapolsky slope
    ETA_LEARNING: 0.1,
    GAMMA_DECAY: 0.05,
    BETA_STRESS: 1.8,
    I_PROTOCOL: 1.2,
    LANDAUER_COST: 0.05,
    INIT_BUDGET: 4.0
};

// --- CLASSES ---

class IdentityKernel {
    constructor(coeffs) {
        this.coeffs = coeffs; // Array of integers
        this.active_depth = coeffs.length;
        this.p = PARAMS.PRIME_BASE;
    }

    metricDistance(other) {
        let min_len = Math.min(this.active_depth, other.active_depth);
        
        for (let k = 0; k < min_len; k++) {
            if (this.coeffs[k] !== other.coeffs[k]) {
                // p^-k
                return Math.pow(this.p, -1 * k);
            }
        }
        if (this.active_depth !== other.active_depth) {
            return Math.pow(this.p, -1 * min_len);
        }
        return 0.0;
    }

    truncate(target_depth) {
        // Enforce min depth of 1 (Root)
        this.active_depth = Math.max(1, Math.min(this.coeffs.length, target_depth));
    }

    expand() {
        if (this.active_depth < this.coeffs.length) {
            this.active_depth++;
            return true;
        }
        return false;
    }
}

class ThermodynamicAgent {
    constructor(id, prf_coeffs, ita_coeffs) {
        this.id = id;
        this.prf_kernel = new IdentityKernel([...prf_coeffs]); // Clone array
        this.ita_kernel = new IdentityKernel([...ita_coeffs]); 
        
        // State
        this.L_GC = 0.3; // Stress
        this.C_PFC = 1.0; // Capacity
        this.legacy = 0.0; // Growth accumulator
        this.is_survival = false;
        
        // Visualization coords (assigned by system)
        this.x = 0;
        this.y = 0;
    }

    step(neighbors, env_entropy, budget) {
        // A. Morphic Fidelity Penalty (Distance between Self and Role)
        const d_morph = this.prf_kernel.metricDistance(this.ita_kernel);

        // B. Update Stress (Inertia + Input)
        const stress_input = env_entropy + (d_morph * 2.0); // Weight debt heavily
        this.L_GC = (0.8 * this.L_GC) + (0.2 * stress_input);

        // C. Sapolsky Function (Capacity Gate)
        let exponent = PARAMS.K_GATE * (this.L_GC - PARAMS.THETA_CRIT);
        exponent = Math.max(-100, Math.min(100, exponent)); // Clamp
        this.C_PFC = 1.0 / (1.0 + Math.exp(exponent));

        // D. Landauer Limit (Thermodynamic Cost)
        // Cost rises with Temp (Stress)
        const T_sys = Math.max(0.1, this.L_GC);
        const max_n = Math.floor(budget / (PARAMS.LANDAUER_COST * T_sys));
        
        const old_depth = this.prf_kernel.active_depth;
        this.prf_kernel.truncate(max_n);

        // Log Truncation Event
        if (this.prf_kernel.active_depth < old_depth && old_depth > 3) {
            return { event: 'truncation', id: this.id };
        }

        // Check Survival Mode
        this.is_survival = this.prf_kernel.active_depth < 3;

        // E. Growth (Accretion)
        this.updateGrowth(env_entropy);
        
        return null;
    }

    updateGrowth(env_entropy) {
        // Simplified Phi (Information Flux)
        const phi = 1.0 / PARAMS.I_PROTOCOL;

        // Accretion: Needs Manual Mode (C_PFC)
        const accretion = PARAMS.ETA_LEARNING * this.C_PFC * phi;

        // Ablation: Decay via Stress
        const decay_factor = Math.exp(PARAMS.BETA_STRESS * this.L_GC);
        const ablation = PARAMS.GAMMA_DECAY * env_entropy * decay_factor;

        const delta = accretion - ablation;
        this.legacy += delta;

        // Structural Expansion
        if (this.legacy > 1.0) {
            if (this.prf_kernel.expand()) {
                this.legacy = 0.0;
            }
        }
    }
}

class UCP_System {
    constructor() {
        this.agents = [];
        this.stepCount = 0;
        this.env_entropy = 0.2;
        this.budget = 4.0;
        this.biobond = false;
        this.strategy = 'Rawls';

        this.initAgents(12); // Small colony for visuals
    }

    initAgents(count) {
        this.agents = [];
        for (let i = 0; i < count; i++) {
            // Generate P-Adic Coeffs (Length 10)
            let prf = [];
            for(let j=0; j<10; j++) prf.push(Math.floor(Math.random() * PARAMS.PRIME_BASE));
            
            // ITA (Role) based on strategy
            // Default: Slight divergence
            let ita = [...prf];
            if (Math.random() > 0.7) ita[2] = (ita[2] + 1) % PARAMS.PRIME_BASE; 

            this.agents.push(new ThermodynamicAgent(i, prf, ita));
        }
    }

    updateStrategy(strat) {
        this.strategy = strat;
        this.agents.forEach(a => {
            if (strat === 'Hobbes') {
                // Hobbes: Force ITA alignment (Order), but lowers F-Vector
                // We model this by making ITA = PRF (low morphic debt) but capping growth
                // Actually, Hobbes enforces external order. Let's make ITA rigid and shared.
                let rigid_ita = [0,0,0,0,0,0,0,0,0,0]; 
                a.ita_kernel = new IdentityKernel(rigid_ita);
            } else if (strat === 'Nozick') {
                // Nozick: High Freedom. ITA matches PRF perfectly (Self-Ownership)
                // But External Entropy is usually higher in simulation (simulated elsewhere)
                a.ita_kernel = new IdentityKernel([...a.prf_kernel.coeffs]);
            } else {
                // Rawls: Support Structures. 
                // We allow some divergence but assume institutions reduce friction.
                // Standard setup.
            }
        });
        logMsg(`Social Contract switched to: ${strat}`, 'info');
    }

    step() {
        this.stepCount++;
        
        // BioBond Intervention
        let effective_entropy = this.env_entropy;
        if (this.biobond) effective_entropy *= 0.4; // Cooling effect

        // Strategy modifiers
        if (this.strategy === 'Hobbes') effective_entropy *= 0.8; // Order reduces noise
        // Nozick relies on the user managing the budget manually

        let truncations = 0;

        this.agents.forEach(agent => {
            // In Nozick mode, agents "pay" for freedom - higher implicit cost
            let effective_budget = this.strategy === 'Nozick' ? this.budget * 0.8 : this.budget;

            let result = agent.step([], effective_entropy, effective_budget);
            if (result && result.event === 'truncation') truncations++;
        });

        if (truncations > 2) logMsg(`Thermal Runaway: ${truncations} agents truncated!`, 'warn');

        return this.getMetrics();
    }

    getMetrics() {
        let avg_stress = this.agents.reduce((sum, a) => sum + a.L_GC, 0) / this.agents.length;
        let avg_depth = this.agents.reduce((sum, a) => sum + a.prf_kernel.active_depth, 0) / this.agents.length;
        
        // Calculate Lambda: <C_PFC> * (1 - V_Surv)
        let avg_cap = this.agents.reduce((sum, a) => sum + a.C_PFC, 0) / this.agents.length;
        let surv_count = this.agents.filter(a => a.is_survival).length;
        let lambda = avg_cap * (1.0 - (surv_count / this.agents.length));

        // Friction (Sampled Diameter)
        // Simplified: avg distance from agent 0
        let dist_sum = 0;
        for(let i=1; i<this.agents.length; i++) {
            dist_sum += this.agents[0].prf_kernel.metricDistance(this.agents[i].prf_kernel);
        }
        let friction = dist_sum / (this.agents.length - 1);

        return { avg_stress, avg_depth, lambda, friction };
    }
}

// --- VISUALIZATION & UI ---

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const sys = new UCP_System();
let running = true;

// Sliders
const entropyInput = document.getElementById('entropySlider');
const budgetInput = document.getElementById('budgetSlider');
const valEntropy = document.getElementById('val-entropy');
const valBudget = document.getElementById('val-budget');

// Event Listeners
entropyInput.addEventListener('input', (e) => {
    sys.env_entropy = parseFloat(e.target.value);
    valEntropy.innerText = sys.env_entropy.toFixed(2);
});
budgetInput.addEventListener('input', (e) => {
    sys.budget = parseFloat(e.target.value);
    valBudget.innerText = sys.budget.toFixed(1);
});

function setStrategy(strat) {
    document.querySelectorAll('.btn-strategy').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    sys.updateStrategy(strat);
}

function toggleBioBond() {
    sys.biobond = !sys.biobond;
    const btn = document.getElementById('biobondBtn');
    if (sys.biobond) {
        btn.innerText = "BIOBOND ACTIVE (COOLING...)";
        btn.style.backgroundColor = "#3b82f6";
        logMsg("BioBond Activated: System Temperature dropping.", "success");
    } else {
        btn.innerText = "ACTIVATE BIOBOND";
        btn.style.backgroundColor = "#10b981";
        logMsg("BioBond Deactivated.", "info");
    }
}

function resetSim() {
    sys.initAgents(12);
    sys.stepCount = 0;
    logMsg("Simulation Reset.", "info");
}

function logMsg(msg, type) {
    const feed = document.getElementById('logFeed');
    const div = document.createElement('div');
    div.className = `log-entry log-${type}`;
    div.innerText = `[T+${sys.stepCount}] ${msg}`;
    feed.prepend(div);
}

// Render Loop
function resize() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
}
window.addEventListener('resize', resize);
resize();

function drawAgent(agent, cx, cy, radius) {
    const depth = agent.prf_kernel.active_depth;
    const max_depth = 10;
    
    // Draw "Halo" based on Capacity (Glow)
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 1.2, 0, Math.PI*2);
    ctx.fillStyle = `rgba(16, 185, 129, ${agent.C_PFC * 0.3})`;
    ctx.fill();

    // Draw concentric circles for P-Adic Layers
    // Root (0-2) -> Trunk (3-6) -> Edge (7+)
    
    for (let i = depth; i > 0; i--) {
        ctx.beginPath();
        let r = (radius / max_depth) * i;
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        
        if (i <= 2) ctx.fillStyle = "#f59e0b"; // Root (Gold)
        else if (i <= 6) ctx.fillStyle = "#3b82f6"; // Trunk (Blue)
        else ctx.fillStyle = "#10b981"; // Edge (Green)
        
        ctx.fill();
        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Stress overlay (Red tint)
    if (agent.L_GC > 0.3) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.fillStyle = `rgba(239, 68, 68, ${Math.min(0.8, (agent.L_GC - 0.3))})`;
        ctx.fill();
    }
}

function animate() {
    if (running) {
        // Physics Step
        const metrics = sys.step();
        
        // Update UI Metrics
        document.getElementById('simTime').innerText = `Step: ${sys.stepCount}`;
        document.getElementById('disp-stress').innerText = metrics.avg_stress.toFixed(2);
        document.getElementById('disp-lambda').innerText = metrics.lambda.toFixed(2);
        document.getElementById('disp-depth').innerText = metrics.avg_depth.toFixed(1);
        document.getElementById('disp-friction').innerText = metrics.friction.toFixed(2);

        // Sapolsky Warning
        const stressElem = document.getElementById('disp-stress').parentElement;
        if (metrics.avg_stress > PARAMS.THETA_CRIT) stressElem.style.borderColor = "#ef4444";
        else stressElem.style.borderColor = "#3b82f6";
    }

    // Drawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const layoutRadius = Math.min(centerX, centerY) * 0.6;

    // Arrange agents in a circle
    sys.agents.forEach((agent, i) => {
        const angle = (i / sys.agents.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * layoutRadius;
        const y = centerY + Math.sin(angle) * layoutRadius;
        
        // Draw connection to center (Gravity/Coherence)
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.strokeStyle = `rgba(148, 163, 184, 0.2)`;
        ctx.stroke();

        drawAgent(agent, x, y, 25);
    });

    // Draw Center "Attractor"
    ctx.beginPath();
    ctx.arc(centerX, centerY, 10, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();

    requestAnimationFrame(animate);
}

// Start
animate();

</script>
</body>
</html>
